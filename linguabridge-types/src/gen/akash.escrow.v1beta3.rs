// This file is @generated by prost-build.
/// AccountID is the account identifier
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccountId {
    #[prost(string, tag = "1")]
    pub scope: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub xid: ::prost::alloc::string::String,
}
impl ::prost::Name for AccountId {
    const NAME: &'static str = "AccountID";
    const PACKAGE: &'static str = "akash.escrow.v1beta3";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.escrow.v1beta3.AccountID".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.escrow.v1beta3.AccountID".into()
    }
}
/// Account stores state for an escrow account
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Account {
    /// unique identifier for this escrow account
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<AccountId>,
    /// bech32 encoded account address of the owner of this escrow account
    #[prost(string, tag = "2")]
    pub owner: ::prost::alloc::string::String,
    /// current state of this escrow account
    #[prost(enumeration = "account::State", tag = "3")]
    pub state: i32,
    /// unspent coins received from the owner's wallet
    #[prost(message, optional, tag = "4")]
    pub balance: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
    /// total coins spent by this account
    #[prost(message, optional, tag = "5")]
    pub transferred: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
    /// block height at which this account was last settled
    #[prost(int64, tag = "6")]
    pub settled_at: i64,
    /// bech32 encoded account address of the depositor.
    /// If depositor is same as the owner, then any incoming coins are added to the Balance.
    /// If depositor isn't same as the owner, then any incoming coins are added to the Funds.
    #[prost(string, tag = "7")]
    pub depositor: ::prost::alloc::string::String,
    /// Funds are unspent coins received from the (non-Owner) Depositor's wallet.
    /// If there are any funds, they should be spent before spending the Balance.
    #[prost(message, optional, tag = "8")]
    pub funds: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
}
/// Nested message and enum types in `Account`.
pub mod account {
    /// State stores state for an escrow account
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// AccountStateInvalid is an invalid state
        Invalid = 0,
        /// AccountOpen is the state when an account is open
        Open = 1,
        /// AccountClosed is the state when an account is closed
        Closed = 2,
        /// AccountOverdrawn is the state when an account is overdrawn
        Overdrawn = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Invalid => "invalid",
                Self::Open => "open",
                Self::Closed => "closed",
                Self::Overdrawn => "overdrawn",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "invalid" => Some(Self::Invalid),
                "open" => Some(Self::Open),
                "closed" => Some(Self::Closed),
                "overdrawn" => Some(Self::Overdrawn),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Account {
    const NAME: &'static str = "Account";
    const PACKAGE: &'static str = "akash.escrow.v1beta3";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.escrow.v1beta3.Account".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.escrow.v1beta3.Account".into()
    }
}
/// Payment stores state for a payment
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FractionalPayment {
    #[prost(message, optional, tag = "1")]
    pub account_id: ::core::option::Option<AccountId>,
    #[prost(string, tag = "2")]
    pub payment_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub owner: ::prost::alloc::string::String,
    #[prost(enumeration = "fractional_payment::State", tag = "4")]
    pub state: i32,
    #[prost(message, optional, tag = "5")]
    pub rate: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
    #[prost(message, optional, tag = "6")]
    pub balance: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
    #[prost(message, optional, tag = "7")]
    pub withdrawn: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::Coin,
    >,
}
/// Nested message and enum types in `FractionalPayment`.
pub mod fractional_payment {
    /// Payment State
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// PaymentStateInvalid is the state when the payment is invalid
        Invalid = 0,
        /// PaymentStateOpen is the state when the payment is open
        Open = 1,
        /// PaymentStateClosed is the state when the payment is closed
        Closed = 2,
        /// PaymentStateOverdrawn is the state when the payment is overdrawn
        Overdrawn = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Invalid => "invalid",
                Self::Open => "open",
                Self::Closed => "closed",
                Self::Overdrawn => "overdrawn",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "invalid" => Some(Self::Invalid),
                "open" => Some(Self::Open),
                "closed" => Some(Self::Closed),
                "overdrawn" => Some(Self::Overdrawn),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for FractionalPayment {
    const NAME: &'static str = "FractionalPayment";
    const PACKAGE: &'static str = "akash.escrow.v1beta3";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.escrow.v1beta3.FractionalPayment".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.escrow.v1beta3.FractionalPayment".into()
    }
}