// This file is @generated by prost-build.
/// ServiceExposeHTTPOptions
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServiceExposeHttpOptions {
    #[prost(uint32, tag = "1")]
    pub max_body_size: u32,
    #[prost(uint32, tag = "2")]
    pub read_timeout: u32,
    #[prost(uint32, tag = "3")]
    pub send_timeout: u32,
    #[prost(uint32, tag = "4")]
    pub next_tries: u32,
    #[prost(uint32, tag = "5")]
    pub next_timeout: u32,
    #[prost(string, repeated, tag = "6")]
    pub next_cases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for ServiceExposeHttpOptions {
    const NAME: &'static str = "ServiceExposeHTTPOptions";
    const PACKAGE: &'static str = "akash.manifest.v2beta2";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.manifest.v2beta2.ServiceExposeHTTPOptions".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.manifest.v2beta2.ServiceExposeHTTPOptions".into()
    }
}
/// ServiceExpose stores exposed ports and hosts details
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServiceExpose {
    /// port on the container
    #[prost(uint32, tag = "1")]
    pub port: u32,
    /// port on the service definition
    #[prost(uint32, tag = "2")]
    pub external_port: u32,
    #[prost(string, tag = "3")]
    pub proto: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub service: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub global: bool,
    #[prost(string, repeated, tag = "6")]
    pub hosts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub http_options: ::core::option::Option<ServiceExposeHttpOptions>,
    /// The name of the IP address associated with this, if any
    #[prost(string, tag = "8")]
    pub ip: ::prost::alloc::string::String,
    /// The sequence number of the associated endpoint in the on-chain data
    #[prost(uint32, tag = "9")]
    pub endpoint_sequence_number: u32,
}
impl ::prost::Name for ServiceExpose {
    const NAME: &'static str = "ServiceExpose";
    const PACKAGE: &'static str = "akash.manifest.v2beta2";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.manifest.v2beta2.ServiceExpose".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.manifest.v2beta2.ServiceExpose".into()
    }
}
/// StorageParams
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StorageParams {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub mount: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub read_only: bool,
}
impl ::prost::Name for StorageParams {
    const NAME: &'static str = "StorageParams";
    const PACKAGE: &'static str = "akash.manifest.v2beta2";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.manifest.v2beta2.StorageParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.manifest.v2beta2.StorageParams".into()
    }
}
/// ServiceParams
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceParams {
    #[prost(message, repeated, tag = "1")]
    pub storage: ::prost::alloc::vec::Vec<StorageParams>,
}
impl ::prost::Name for ServiceParams {
    const NAME: &'static str = "ServiceParams";
    const PACKAGE: &'static str = "akash.manifest.v2beta2";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.manifest.v2beta2.ServiceParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.manifest.v2beta2.ServiceParams".into()
    }
}
/// Credentials to fetch image from registry
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServiceImageCredentials {
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
}
impl ::prost::Name for ServiceImageCredentials {
    const NAME: &'static str = "ServiceImageCredentials";
    const PACKAGE: &'static str = "akash.manifest.v2beta2";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.manifest.v2beta2.ServiceImageCredentials".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.manifest.v2beta2.ServiceImageCredentials".into()
    }
}
/// Service stores name, image, args, env, unit, count and expose list of service
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub image: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub resources: ::core::option::Option<super::super::base::v1beta3::Resources>,
    #[prost(uint32, tag = "7")]
    pub count: u32,
    #[prost(message, repeated, tag = "8")]
    pub expose: ::prost::alloc::vec::Vec<ServiceExpose>,
    #[prost(message, optional, tag = "9")]
    pub params: ::core::option::Option<ServiceParams>,
    #[prost(message, optional, tag = "10")]
    pub credentials: ::core::option::Option<ServiceImageCredentials>,
}
impl ::prost::Name for Service {
    const NAME: &'static str = "Service";
    const PACKAGE: &'static str = "akash.manifest.v2beta2";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.manifest.v2beta2.Service".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.manifest.v2beta2.Service".into()
    }
}
/// Group store name and list of services
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub services: ::prost::alloc::vec::Vec<Service>,
}
impl ::prost::Name for Group {
    const NAME: &'static str = "Group";
    const PACKAGE: &'static str = "akash.manifest.v2beta2";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.manifest.v2beta2.Group".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.manifest.v2beta2.Group".into()
    }
}